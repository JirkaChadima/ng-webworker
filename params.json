{"name":"Ng-webworker","tagline":"Angular web worker","body":"#ng-webworker\r\n[https://github.com/mattslocum/ng-webworker](https://github.com/mattslocum/ng-webworker)\r\n\r\n###Installation for Testing\r\n\r\n    npm install\r\n\r\n###Run Tests\r\n\r\n    grunt karma\r\n\r\n###Build\r\n\r\n    grunt uglify\r\n\r\n\r\n#Using ng-webworker\r\n## Basic Usage\r\n\r\n###Include the module\r\n```javascript\r\nangular.module('demo', ['ngWebworker'])\r\n    .controller('demoCtrl', function($scope, Webworker) {});\r\n```\r\n\r\n###Create a basic worker\r\n```javascript\r\n// function that will become a worker\r\nfunction doubler(num) {\r\n    // the return value becomes the resolve of the promise\r\n    return num * 2;\r\n}\r\n\r\nvar myWorker = Webworker.create(doubler);\r\n```\r\n\r\n###call the worker function\r\n```javascript\r\nmyWorker.run($scope.value).then(function(result) {\r\n    alert(\"Answer: \" + result);\r\n});\r\n```\r\n\r\n\r\n\r\n##Create an advanced worker\r\n### Async (notification) promises\r\nLets say you want the notification support for webworkers for things like progress bars. There are times you do not want the return value to resolve the function. Maybe you are doing api requests or some other async tasks. An api of two functions is injected into the web worker. If an error is thrown, it will reject.\r\n* complete - This will resolve the promise\r\n* notify - Send a notification of data via the promise\r\n```javascript\r\n// function that will become a worker\r\nfunction async(first, second) {\r\n    // api to send a promise notification\r\n    notify(first);\r\n    // api to resolve the promise. Note: according to the $q spec, \r\n    // a promise cannot be used once it has been resolved or rejected.\r\n    complete(second);\r\n}\r\n\r\n// mark this worker as one that supports async notifications\r\nvar myWorker = Webworker.create(async, {async: true });\r\n\r\n// uses the native $q style notification: https://docs.angularjs.org/api/ng/service/$q\r\nmyWorker.run(1, 2).then(function(result) {\r\n    // promise is resolved.\r\n    alert('done');\r\n}, null, function(progress) {\r\n    // promise has a notification\r\n    console.log(progress);\r\n);\r\n```\r\n\r\n### Extra config\r\nIf you want callback style functions on top of the promise or as an alternative style, you can pass callbacks into the config block. These callbacks only work if async is true. When async is false it uses basic resolves when the function returns.\r\n```javascript\r\nvar myWorker = Webworker.create(async, {\r\n    async: true, // prevent the function return from resolving the promise\r\n    useHelper: true/false, // defaults to false for most browsers. defaults to true for IE.\r\n    onMessage: function(event) {}, // every event from the worker fires this when async:true\r\n    onError: function(event) {}, // error event from the worker\r\n    onReturn: function(data) {}, // return value from the function\r\n    onComplete: function(data) {}, // data from complete/resolve function\r\n    onNotice: function(data) {} // data from notice function\r\n});\r\n```\r\n\r\n### IE workarounds\r\nIE strikes again. The way ng-webwork can take a function and turn it into a webworker is by transforming your function into a Blob and executing that blob in a web worker like you would an independant file. Unfortunatly, IE treats blobs as cross domain. The solution is to have a worker shell file that is loaded as a separate file. Your function is strigified and then messaged over to the worker file and evaled to make it behave just like the blobs did. \r\n\r\n","google":"UA-60741296-1","note":"Don't delete this file! It's used internally to help with page regeneration."}